<?php

namespace Eril\TblClass\Generators;

use Eril\TblClass\Config;
use Eril\TblClass\Schema\SchemaReaderInterface;

/**
 * Gera as classes Tbl + TblNomeDaTabela
 */
class TableClassesGenerator extends Generator
{
    public function __construct(
        SchemaReaderInterface $schema,
        Config $config,
        bool $checkMode = false
    ) {
        // parent::__construct(schema, config, checkMode, mode)
        parent::__construct($schema, $config, $checkMode, 'schema');
    }

    /**
     * Gera o conteúdo completo do arquivo PHP
     */
    protected function generateContent(array $tables, array $foreignKeys = [], ?string $schemaHash = null): string
    {
        $content  = "<?php\n\n";
        $content .= $this->generateHeader($schemaHash);
        $content .= $this->generateTblClass($tables);
        $content .= $this->generateTableClasses($tables, $foreignKeys);
        $content .= "\n// auto-generated by tbl-class v4\n";

        return $content;
    }

    private function generateHeader(?string $schemaHash): string
    {
        $time = date('Y-m-d H:i:s');
        return <<<PHP
/**
 * Database schema classes
 *
 * @schema-hash md5:$schemaHash
 * @generated   $time
 * @tool        tbl-class
 * @ince 4
 * 
 * ⚠ AUTO-GENERATED - DO NOT EDIT
 */

PHP;
    }

    private function generateTblClass(array $tables): string
    {
        $content = "class Tbl\n{\n";

        foreach ($tables as $table) {
            $const = $this->namingResolver->getTableConstName($table, 'full');
            $content .= "    public const $const = '$table';\n";
        }

        $content .= "\n    // ALIAS \n\n";
        foreach ($tables as $table) {
            $const = $this->namingResolver->getTableConstName($table, 'full');
            $alias    = $this->namingResolver->getTableAlias($table);
            $content .= "    public const as_$const = '$table $alias';\n";
        }

        $content .= "}\n\n";
        return $content;
    }

    private function generateTableClasses(array $tables, array $foreignKeys): string
    {
        $content = '';

        foreach ($tables as $table) {

            $className = 'Tbl' . $this->tableClassName($table);
            $columns = $this->schema->getColumns($table);
            $enums  = $this->schema->getEnums($table);
            $fks = array_filter($foreignKeys, fn($fk) => $fk['from_table'] === $table);

            // class
            $content .= "class {$className}\n{\n";

            // Columns
            foreach ($columns as $column) {
                // $name = $this->namingResolver->getColumnConstName(null, $column);
                $content .= "    public const {$column} = '{$column}';\n";
            }

            // ENUMs
            if (!empty($enums)) {
                $content .= "\n    // ENUM values\n\n";
                foreach ($enums as $name => $value) {
                    $content .= "    public const enum_{$name} = '{$value}';\n";
                }
            }

            // Foreign Keys
            if (!empty($fks)) {
                $content .= "\n    // Foreign Keys\n\n";
                foreach ($fks as $fk) {
                    $content .= "    /* FK → `{$fk['to_table']}`.`{$fk['to_column']}` */ public const fk_{$fk['to_table']} = '{$fk['from_column']}';\n";
                }
            }

            $content .= "\n    public const _TABLE = '{$table}';\n";
            $content .= "    public const _ALIAS = '{$this->namingResolver->getTableAlias($table)}';\n";
            $content .= "}\n\n";
        }

        return $content;
    }

    private function tableClassName(string $table): string
    {
        $tableName = $this->namingResolver->getTableConstName($table);
        return str_replace(' ', '', ucwords(str_replace('_', ' ', $tableName)));
    }
}
